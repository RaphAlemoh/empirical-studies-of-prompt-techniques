  // Solution using a priority queue
  class ListNode {
    public int $val;
    public ?ListNode $next;
    public function __construct(int $val = 0, ?ListNode $next = null) {
        $this->val = $val;
        $this->next = $next;
    }
}

function mergeKLists(array $lists): ?ListNode {
    if (empty($lists)) {
        return null;
    }

    // Create a priority queue to store the nodes of the linked lists
    $pq = new SplPriorityQueue();

    // Add the head nodes of each linked list to the priority queue
    foreach ($lists as $list) {
        if ($list !== null) {
            $pq->insert($list, $list->val);
        }
    }

    // Create a new merged linked list and return its head node
    $dummy = new ListNode(0);
    $current = $dummy;

    while (!$pq->isEmpty()) {
        $current->next = $pq->extract();
        $current = $current->next;
        if ($current->next !== null) {
            $pq->insert($current->next, $current->next->val);
        }
    }

    return $dummy->next;
}

// Example usage:
$lists = [new ListNode(1), new ListNode(2), new ListNode(3)];
$mergedList = mergeKLists($lists); // Returns a new linked list with the values 1, 2, and 3 in sorted order

// Output: 1->2->3

