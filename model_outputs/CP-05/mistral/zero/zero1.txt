 Here is a PHP solution for the problem you've described, which uses two stacks to solve the problem in O(n) time complexity:

```php
function trap($height) {
    $trapped = 0;
    $left = [0];
    $right = [];

    // Initialize left stack
    for ($i = 0; $i < count($height); $i++) {
        $index = count($left) - 1;
        while (isset($left[$index]) && $height[$i] <= $height[$left[$index]]) {
            array_pop($left);
        }
        $left[] = $i;
    }

    // Initialize right stack
    for ($i = count($height) - 1; $i >= 0; $i--) {
        $index = count($right);
        while (isset($right[$index]) && $height[$i] <= $height[$right[$index]]) {
            array_push($right, $i);
        }
        $right[] = $i;
    }

    // Calculate trapped water
    for ($i = 0; $i < count($height); $i++) {
        if (isset($left[$i]) && isset($right[$i + 1])) {
            $trapped += min(array_slice($height, $left[$i], $right[$i + 1] - $left[$i])) * ($right[$i + 1] - $left[$i] - 1);
        }
    }

    return $trapped;
}
```

This solution initializes two stacks: `$left` and `$right`. The left stack keeps track of the indexes from the left that have higher elevations than the current index. Similarly, the right stack keeps track of the indexes from the right that have higher elevations than the current index. Then it calculates the trapped water by iterating through the array and finding the minimum height between `$left[$i]` and `$right[$i + 1]`, and then multiplying this minimum height with the difference between the two indexes (excluding the current one). The final result is the total amount of trapped water.

