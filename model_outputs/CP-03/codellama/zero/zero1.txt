
The problem can be solved using a binary search algorithm. The idea is to start from the top-left corner of the matrix and move towards the bottom-right corner, looking for the target value. At each step, we check if the target value is greater than or equal to the current element in the matrix, and if it is less than or equal to the previous element in the row. If the target value is found, we return true. If the search reaches the bottom-right corner of the matrix without finding the target value, we return false.
```php
function searchMatrix(array $matrix, int $target): bool {
    $m = count($matrix);
    $n = count($matrix[0]);

    $top = 0;
    $bottom = $m * $n - 1;

    while ($top <= $bottom) {
        $mid = floor(($top + $bottom) / 2);
        $row = (int) ($mid / $n);
        $col = $mid % $n;

        if ($matrix[$row][$col] >= $target) {
            // check if the target value is greater than or equal to the previous element in the row
            if ($col > 0 && $matrix[$row][$col - 1] <= $target) {
                return true;
            }

            // move right
            $top = $mid + 1;
        } else {
            // check if the target value is less than or equal to the current element in the row
            if ($matrix[$row][$col] <= $target) {
                return true;
            }

            // move down
            $bottom = $mid - 1;
        }
    }

    return false;
}
```
The time complexity of this algorithm is O(log(m * n)), as we only need to check at most log(m * n) elements in the matrix. The space complexity is O(1), as we only use a few variables to keep track of the top and bottom pointers in the array.

