 Here is a PHP implementation of the binary search algorithm that meets the given constraints and has a time complexity of O(log(m * n)):

```php
function searchMatrix($matrix, $target) {
    $m = count($matrix);
    if ($m === 0) return false;

    $left = 0;
    $right = $m * $matrix[0]->size();

    while ($left < $right) {
        $mid = floor(($left + $right) / 2);
        $rowIndex = intval($mid / $matrix[0]->size());
        $colIndex = $mid % $matrix[0]->size();

        if ($target === $matrix[$rowIndex][$colIndex]) {
            return true;
        }

        // If the target is greater than the current element, we search in the second half of the matrix
        if ($matrix[$rowIndex][$colIndex] < $target) {
            $left = $mid + 1;
        } else {
            $right = $mid;
        }
    }

    return false;
}
```

In this solution, the matrix is treated as a linear array of rows. The binary search is performed on this linear array with appropriate adjustments for row and column index calculations. Since each row is sorted in non-decreasing order and the first integer of each row is greater than the last integer of the previous row, the target can only be found within the bounds of the searched subarray at each iteration. This ensures a time complexity of O(log(m * n)).

